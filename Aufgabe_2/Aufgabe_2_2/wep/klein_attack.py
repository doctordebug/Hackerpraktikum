from collections import Counter

import sys

import datetime

from Aufgabe_2.utils import log
from wep.iv_and_cipher_generator import iv_and_stream_cipher_generator

def simulate_permutation(part_of_key, n=256):
    """
    Approximate the permutation by simulating the first i steps
    of the key scheduling of RC4
    :param part_of_key: Known part of the main key
    :return: S-box permuted to step i-1
    """
    # Initialize s-box
    s = []
    for i in range(n):
        s.append(i)

    i, j = 0, 0
    # Calculate permutation for first i bytes
    for i in range(len(part_of_key)):
        j = (j + s[i] + part_of_key[i]) % n
        s[i], s[j] = s[j], s[i]
    return s, i, j


def calculate_key_byte(stream_cipher, s_box, i, j, n):
    """
    Approximate the key byte at position i
    :param stream_cipher: RC4 stream cipher
    :param s_box: S-box at step i-1
    :param i: iterator
    :param j: iterator at step i-1
    :param n: Base of the integer group
    :return: key byte at position i
    """
    s_invert = []
    for init in range(n):
        s_invert.append(init)

    # Invert s-box
    for r in range(len(s_box)):
        s_invert[s_box[r]] = r

    # Calculate nex key byte
    key_byte = (s_invert[(i - stream_cipher[i - 1]) % n] - (j + s_invert[i]) % n) % n
    return key_byte


def crack_wep(iv_stream_pair, key_length_bytes, n, tuple_amount=sys.maxsize):
    """
    Method to approximate the main key of wep. The stream cipher is the RC4 stream
    cipher generated by running RC with arguments iv and main_key.
    :param iv_stream_pair: Set of tuples containing iv and cipher stream
    :param key_length_bytes: length of main wep key in byte
    :param n: Base of integer group
    :param tuple_amount: Amount of tuples which should be used from the set above
    :return: The approximated main wep key
    """
    possible_key = bytearray()
    key_length = key_length_bytes - len(possible_key) % key_length_bytes

    for b in range(key_length):
        candidates = []
        for index, tuple in enumerate(iv_stream_pair):
            if index > tuple_amount:
                break
            compound_key = bytearray()
            compound_key.extend(tuple[0])
            if possible_key:
                compound_key.extend(possible_key)
            # Internal permutation S_(i-1) and index j at (i-1)th step
            s_box, i, j = simulate_permutation(compound_key)
            # Calculate possible key byte K[i]
            candidates.append(calculate_key_byte(tuple[1], s_box, i + 1, j, n))
        candidate_byte = Counter(candidates).most_common(1)[0][0]
        possible_key.append(candidate_byte)
    return possible_key


def crack_simulation(n=256, tuple_amount=90000, rounds=1, key_length=40):
    """
    Method for cracking the wep simulation. The return value of this function will show a tuple of a
    possible key, which is calculated by the attacker, and the original main key. If both values are equal
    the attack was a success.
    :param n: Base of the integer group
    :param tuple_amount:  Amount of tuples which should be used from the set above
    :param rounds: Amount of rounds the pseudo random generator should be called
    :param key_length: length of the key in bits
    :return: Returns a pair of possible key and the original main key
    """
    start = datetime.datetime.now()
    key_length_bytes = int(key_length / 8)

    # Retrieve sample set of bytearray tuples
    log("Collection Key Stream ... ", level=0)
    iv_stream_pair, main_key = iv_and_stream_cipher_generator(tuple_amount=tuple_amount, rounds=rounds, n=n, cache=True)
    log("Key Stream collected after {}ms".format(int((datetime.datetime.now() - start).total_seconds() * 1000)),
        level=0)

    # Crack wep by approximating main key bytes from (iv, stream cipher) pairs
    log("Start Hacking {} ms".format(int((datetime.datetime.now() - start).total_seconds() * 1000)), level=0)
    possible_key = crack_wep(iv_stream_pair, key_length_bytes, n, tuple_amount)

    ms_end = int((datetime.datetime.now() - start).total_seconds() * 1000)
    s_end = int((datetime.datetime.now() - start).total_seconds())
    log("Key found after {}ms ({} seconds)".format(ms_end, s_end), level=0)
    return possible_key, main_key


if __name__ == '__main__':
    keys = []
    for i in reversed(range(0, 50000, 10000)):
        keys.append(dict(tuple_amount=i, key=crack_simulation(tuple_amount=i)))
    print(keys)
