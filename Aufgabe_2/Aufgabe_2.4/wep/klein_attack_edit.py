import base64
import datetime
import multiprocessing
import sys
from collections import Counter
from multiprocessing.pool import Pool

from rc4 import rc4
from utils import log
from wep.iv_and_cipher_generator import iv_and_stream_key_generator


def simulate_permutation(part_of_key, n=256):
    """
    Approximate the permutation by simulating the first i steps
    of the key scheduling of RC4
    :param part_of_key: Known part of the main key
    :return: S-box permuted to step i-1
    """
    # Initialize s-box
    s = []
    for i in range(n):
        s.append(i)

    i, j = 0, 0
    # Calculate permutation for first i bytes
    for i in range(len(part_of_key)):
        j = (j + s[i] + part_of_key[i]) % n
        s[i], s[j] = s[j], s[i]
    return s, i, j


def simulate_permutation_2(part_of_key, n=256):
    """
    Approximate the permutation by simulating the first i steps
    of the key scheduling of RC4
    :param part_of_key: Known part of the main key
    :return: S-box permuted to step i-1
    """
    # Initialize s-box
    s = []
    for i in range(n):
        s.append(i)

    i, j = 0, 0
    # Calculate permutation for first i bytes
    s_prev = []
    for i in range(len(part_of_key)):
        s_prev = s
        j = (j + s[i] + part_of_key[i]) % n
        s[i], s[j] = s[j], s[i]
    return s, i, j, s_prev


def calculate_key_byte(key_stream, s_box, i, j, n):
    """
    Approximate the key byte at position i
    :param key_stream: RC4 key stream
    :param s_box: S-box at step i-1
    :param i: iterator
    :param j: iterator at step i-1
    :return: key byte at position i
    """
    s_invert = []
    for init in range(n):
        s_invert.append(init)

    # Invert s-box
    for r in range(len(s_box)):
        s_invert[s_box[r]] = r

    # Calculate next key byte
    key_byte = (s_invert[(i - key_stream[i - 1]) % n] - (s_box[i] + j) % n) % n
    return key_byte


def crack_wep(iv_stream_pair, n, tuple_amount=sys.maxsize, possible_key=bytearray(), candidate_amount=5):
    """
    Method to approximate the main wep key. The cipher stream is the RC4 stream
    cipher generated by running RC with (iv || main_key).
    :param iv_stream_pair: Set of tuples containing iv and cipher stream
    :param key_length_bytes: length of main wep key in byte
    :param n: Base of integer group
    :param tuple_amount: Amount of tuples which should be used from the set above
    :return: The approximated main wep key
    """
    candidates = []
    for index, tuple in enumerate(iv_stream_pair):
        if index > tuple_amount:
            break
        compound_key = bytearray()
        compound_key.extend(tuple.get('iv'))
        if possible_key:
            compound_key.extend(possible_key)
        # Internal permutation S_(i-1) and index j at (i-1)th step
        s_box, i, j = simulate_permutation(compound_key)
        # Calculate possible key byte K[i]
        next_key_byte = calculate_key_byte(tuple.get('stream_key'), s_box, i + 1, j, n)
        candidates.append(next_key_byte)

    # Save bytes with probability
    candidates_and_percentages = []
    for candidate_tuple in Counter(candidates).most_common(candidate_amount):
        p = candidate_tuple[1] / tuple_amount
        candidates_and_percentages.append((candidate_tuple[0], p))
    # Sort tuples in descending order
    sorted_candidates = sorted(candidates_and_percentages, key=lambda x: x[1], reverse=True)
    return sorted_candidates, possible_key


def approximate(key_stream, s_box, s_box_prev, i, j, n):
    s_invert = []
    for init in range(n):
        s_invert.append(init)

    # Invert s-box
    for r in range(len(s_box)):
        s_invert[s_box[r]] = r

    # Calculate next key byte
    key_byte = (s_invert[((i + 1) - key_stream[(i + 1) - 1]) % n] - (s_box[i + 1] + j + s_box_prev[i]) % n) % n

    return key_byte


result_list = []


def log_result(result):
    result_list.append(result)


def crack_simulation(n=256, tuple_amount=30000, rounds=1, key_length=40, iv_length=24):
    # Get iv and stream_key pairs
    iv_stream_pair, main_key = iv_and_stream_key_generator(tuple_amount=tuple_amount, rounds=rounds, n=n,
                                                           key_length=key_length, iv_length=iv_length)
    # Print main wep key
    print(main_key[0], main_key[1], main_key[2], main_key[3])
    # Calculate K[i] + K[i+1] using
    # simulate_permutation_2 (additionally returns s_box permuted to step i ) and
    # approximate (altered calculate_key_byte function as in chapter 4 in 60 sec paper)
    candidates = []
    for index, tuple in enumerate(iv_stream_pair):
        if index > tuple_amount:
            break
        compound_key = bytearray()
        compound_key.extend(tuple.get('iv'))
        # Internal permutation S_(i-1) and index j at (i-1)th step
        s_box, i, j, s_box_prev = simulate_permutation_2(compound_key)
        # Calculate possible key byte K[i]
        next_key_byte = approximate(tuple.get('stream_key'), s_box, s_box_prev, i + 1, j, n)
        candidates.append(next_key_byte)
        print("next candidates: {}".format(len(candidates)))

    # Save bytes with probability
    candidates_and_percentages = []
    for candidate_tuple in Counter(candidates).most_common(5):
        p = candidate_tuple[1] / tuple_amount
        candidates_and_percentages.append((candidate_tuple[0], p))
    # Sort tuples in descending order
    sorted_candidates = sorted(candidates_and_percentages, key=lambda x: x[1], reverse=True)
    print("Arithmetic sum, K[i]+K[i+1]: {}".format(sorted_candidates))

    print("Approximated key byte: {}".format(
        crack_wep(iv_stream_pair, n, tuple_amount, candidate_amount=5)))
    # Some probability described in 60 sec paper
    print("Prob: {}".format((((1 - 1 / n) ** (n - 2)) * (2 / n) + (1 - (1 - 1 / n) ** (n - 2)) * ((n - 2) / (n * (n - 1))))))

    # Parallel execution using multiprocessing module
    # pool = multiprocessing.Pool()
    # for i in range(3):
    #    pool.apply_async(crack_wep, args=(iv_stream_pair, n, tuple_amount),
    #                     kwds={'possible_key': bytearray([first_byte_candidates[i][0]])}, callback=log_result)
    # pool.close()
    # pool.join()
    # print(result_list)

def crack_simulation_oli(n=256, tuple_amount=50000, rounds=1, key_length=40, iv_length=24, possible_key=""):
    # Get iv and stream_key pairs
    iv_stream_pair, main_key = iv_and_stream_key_generator(tuple_amount=tuple_amount, rounds=rounds, n=n,
                                                           key_length=key_length, iv_length=iv_length,cache=True)
    # Print main wep key
    print("New key:")
    print(main_key[0], main_key[1], main_key[2], main_key[3])
    print("Expecting value:")
    print((main_key[0] + main_key[1]) % 256)
    count_arr = []
    top_10 = []

    for index, tuple in enumerate(iv_stream_pair):
        if index > tuple_amount:
            break
        compound_key = bytearray()
        compound_key.extend(tuple.get('iv'))
        s_box, i, j, s_box_prev = simulate_permutation_2(compound_key)
        x = tuple.get('stream_key')
        key_byte_sum_of_first_two_bytes_long_var_name = approximate(x, s_box, s_box_prev, i + 1, j, n)
        count_arr.append(key_byte_sum_of_first_two_bytes_long_var_name)

    for candidate_tuple in Counter(count_arr).most_common(10):
        top_10.append(candidate_tuple[0])
    print(top_10)

    key_candidates = crack_wep(iv_stream_pair, n, tuple_amount, candidate_amount=10)

    #krank! Wer baut solche Funktionsr√ºckgaben?
    k_0 = key_candidates[0][0][0]
    print("First Keybyte: "+str(k_0))

    key_candidates_2 = crack_wep(iv_stream_pair, n, tuple_amount, candidate_amount=10, possible_key=bytearray([k_0]))
    k_1 = key_candidates_2[0][0][0]
    print("Second Keybyte: " + str(k_1))

    sum_1 = (k_0 + k_1) % 256

    if sum_1 in top_10:
        print("the first two bytes seem to be correct!")
        key_candidates_3 = crack_wep(iv_stream_pair, n, tuple_amount, candidate_amount=10, possible_key=bytearray([k_0,k_1]))
        k_2 = key_candidates_3[0][0][0]
        print("Third Keybyte: " + str(k_2))

        # und so weiter ......
        key_candidates_4 = crack_wep(iv_stream_pair, n, tuple_amount, candidate_amount=10, possible_key=bytearray([k_0, k_1,k_2]))
        k_3 = key_candidates_4[0][0][0]
        print("Fourth Keybyte: " + str(k_3))
    else:
        print("The first tow bytes seem to be not correct!")

def invert_s(s_box,  n):
    s_invert = []
    for init in range(n):
        s_invert.append(init)
     # Invert s-box
    for r in range(len(s_box)):
        s_invert[s_box[r]] = r
    return s_invert


if __name__ == '__main__':
    #for i in range(5):
    crack_simulation_oli()
